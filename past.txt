==============================================================
   ΕΡΓΑΣΤΗΡΙΟ ΜΙΚΡΟΫΠΟΛΟΓΙΣΤΩΝ - ΘΕΩΡΗΤΙΚΕΣ ΕΡΩΤΗΣΕΙΣ & ΑΠΑΝΤΗΣΕΙΣ
==============================================================

ΕΥΡΕΤΗΡΙΟ
----------
1η ΒΑΡΔΙΑ
  1.1  Διαφορά STS και OUT
  1.2  Τι πρόβλημα αν δεν αρχικοποιηθεί ο SP
  1.3  Χρήση διαφορετικών τρόπων χρονισμού (timer, delay)
  1.4  Περιγραφή χρήσης ADC με polling και interrupt
  1.5  Πλεονεκτήματα/μειονεκτήματα PCA9555

2η ΒΑΡΔΙΑ
  2.1  Γιατί αρχικοποιούμε τον SP στην κορυφή της μνήμης
  2.2  Πότε και γιατί κάνουμε αρχικοποίηση σε πρόγραμμα AVR
  2.3  Σφάλμα ADC με μεγάλη αντίσταση εισόδου / Δύο τρόποι υλοποίησης ADC / ADC 10bit 10kHz σε 1-wire

3η ΒΑΡΔΙΑ
  3.1  Πληκτρολόγιο 9 κουμπιών με 6 ακροδέκτες
  3.2  Μικροελεγκτής χωρίς IN/OUT - τι συμβαίνει
  3.3  Πώς λειτουργεί η στοίβα, δομή, παράδειγμα
  3.4  Μετατροπή αναλογικού σε ψηφιακό χωρίς DAC
  3.5  Πώς το TWI επιτρέπει πολλαπλές συσκευές και multi-master

4η ΒΑΡΔΙΑ (ΕΞΕΤΑΣΗ ΦΕΒ 2023)
  4.1  Bouncing/σπινθηρισμός - προβλήματα και αντιμετώπιση
  4.2  Μηχανισμός διακοπής υπερχείλισης Timer/Counter1
  4.3  Σύγκριση TWI με 1-Wire
  4.4  Χρήση διακοπών σε μικροελεγκτή
  4.5  Ταυτόχρονο πάτημα δύο πλήκτρων στο πληκτρολόγιο

ΤΕΛΕΥΤΑΙΑ ΒΑΡΔΙΑ
  5.1  Ανάγνωση 16bit καταχωρητή Timer (TEMP register)
  5.2  Βραχυκύκλωμα πιν στα 5V με κλείσιμο διακόπτη
  5.3  Χρήση RAM και ROM στον AVR
  5.4  Θερμόμετρο 1msec/0.1°C μέσω 1-wire
  5.5  Γιατί ο SP αρχικοποιείται στην κορυφή της μνήμης

ΓΕΝΙΚΕΣ ΕΡΩΤΗΣΕΙΣ (αναφέρονται στο αρχείο)
  Γ.1  Τι κάνει η pull-up αντίσταση
  Γ.2  Διαφορά μικροελεγκτή και μικροεπεξεργαστή


==============================================================
                         ΑΠΑΝΤΗΣΕΙΣ
==============================================================

--------------------------------------------------------------
1η ΒΑΡΔΙΑ
--------------------------------------------------------------

1.1) ΕΡΩΤΗΣΗ: Διαφορά STS και OUT

ΑΠΑΝΤΗΣΗ:
- OUT: Γράφει δεδομένα από καταχωρητή σε I/O register. Λειτουργεί ΜΟΝΟ για διευθύνσεις I/O 0x00-0x3F (δηλαδή διευθύνσεις μνήμης 0x20-0x5F). Εκτελείται σε 1 κύκλο μηχανής. Σύνταξη: out PORTB, r24.
- STS: Γράφει δεδομένα από καταχωρητή σε οποιαδήποτε θέση μνήμης (data space). Χρησιμοποιείται ΥΠΟΧΡΕΩΤΙΚΑ για καταχωρητές με διεύθυνση > 0x5F (π.χ. EICRA στη 0x69, ADMUX, ADCSRA, TIMSK1, TCCR1B κ.λπ.). Εκτελείται σε 2 κύκλους μηχανής. Σύνταξη: sts EICRA, r24.
Παράδειγμα: Ο EICRA (0x69) απαιτεί sts, ενώ ο PORTB (0x25) μπορεί να χρησιμοποιήσει out.
Αντίστοιχα, η IN διαβάζει I/O registers (0x00-0x3F) και η LDS διαβάζει από οποιαδήποτε θέση μνήμης.


1.2) ΕΡΩΤΗΣΗ: Τι πρόβλημα θα έχεις αν ο SP δεν αρχικοποιηθεί;

ΑΠΑΝΤΗΣΗ:
Αν δεν αρχικοποιηθεί ο Stack Pointer, μετά από reset δείχνει στη διεύθυνση 0x0000. Αυτό σημαίνει ότι:
- Κάθε κλήση υπορουτίνας (rcall/call) ή διακοπή θα γράψει τη διεύθυνση επιστροφής σε λάθος θέση μνήμης (πάνω στους I/O registers ή τους καταχωρητές γενικής χρήσης), καταστρέφοντας δεδομένα.
- Οι εντολές push/pop δε θα λειτουργούν σωστά.
- Τα ret/reti θα επιστρέψουν σε τυχαίες/λάθος διευθύνσεις, προκαλώντας απρόβλεπτη συμπεριφορά ή κρέμασμα.
Γι' αυτό πάντα αρχικοποιούμε: ldi r24, low(RAMEND) / out SPL, r24 / ldi r24, high(RAMEND) / out SPH, r24.


1.3) ΕΡΩΤΗΣΗ: Χρήση διαφορετικών τρόπων χρονισμού (timer, delay)

ΑΠΑΝΤΗΣΗ:
- Software Delay (busy-wait): Ο επεξεργαστής εκτελεί ένα βρόχο NOP/sbiw μέχρι να περάσει ο επιθυμητός χρόνος. Πλεονέκτημα: απλή υλοποίηση. Μειονέκτημα: ο επεξεργαστής δεν μπορεί να κάνει τίποτα άλλο (blocking), σπαταλά κύκλους.
- Hardware Timer: Χρησιμοποιούμε τον ενσωματωμένο Timer/Counter (π.χ. TCNT1). Τον φορτώνουμε με αρχική τιμή, επιλέγουμε prescaler, και όταν υπερχειλίσει δημιουργεί διακοπή ή θέτει flag. Πλεονέκτημα: ο επεξεργαστής είναι ελεύθερος να εκτελεί άλλο κώδικα (non-blocking). Μειονέκτημα: πιο σύνθετη ρύθμιση.
Ο Timer είναι προτιμότερος σε εφαρμογές πραγματικού χρόνου.


1.4) ΕΡΩΤΗΣΗ: Περιγραφή χρήσης ADC με polling και interrupt

ΑΠΑΝΤΗΣΗ:
α) Polling: Θέτουμε το bit ADSC στον ADCSRA για να ξεκινήσει η μετατροπή. Στη συνέχεια ελέγχουμε συνεχώς (σε βρόχο) αν το ADSC έγινε 0 (η μετατροπή ολοκληρώθηκε). Μόλις ολοκληρωθεί, διαβάζουμε ADCL και μετά ADCH. Πλεονέκτημα: απλός κώδικας. Μειονέκτημα: ο επεξεργαστής περιμένει (blocking).

β) Interrupt: Ενεργοποιούμε το bit ADIE στον ADCSRA και την εντολή sei. Ξεκινάμε τη μετατροπή (ADSC=1) και ο επεξεργαστής συνεχίζει άλλη εργασία. Όταν ολοκληρωθεί η μετατροπή, ο ADC δημιουργεί διακοπή (vector 0x2A) και στη ρουτίνα εξυπηρέτησης διαβάζουμε το αποτέλεσμα. Πλεονέκτημα: non-blocking. Μειονέκτημα: πιο σύνθετος κώδικας.


1.5) ΕΡΩΤΗΣΗ: Πλεονεκτήματα/μειονεκτήματα PCA9555

ΑΠΑΝΤΗΣΗ:
Πλεονεκτήματα:
- Παρέχει 16 επιπλέον ακροδέκτες I/O (2 θύρες x 8 bit) χωρίς να χρησιμοποιεί πολλούς ακροδέκτες του μικροελεγκτή (χρειάζεται μόνο 2: SDA + SCL μέσω TWI).
- Μπορούν να συνδεθούν έως 8 PCA9555 στον ίδιο δίαυλο TWI (μέσω A0-A2), δίνοντας έως 128 I/O.
- Διαθέτει εσωτερικές pull-up αντιστάσεις στις εισόδους.
- Έχει interrupt output για ειδοποίηση αλλαγής κατάστασης εισόδων.

Μειονεκτήματα:
- Πιο αργή πρόσβαση σε σχέση με τις εσωτερικές θύρες, λόγω σειριακής επικοινωνίας TWI.
- Πιο σύνθετος κώδικας (πρέπει να στέλνουμε command bytes μέσω TWI).
- Απαιτεί pull-up αντιστάσεις στο δίαυλο TWI.
- Δεν μπορεί να χρησιμοποιηθεί για εφαρμογές που απαιτούν πολύ γρήγορη εναλλαγή I/O (π.χ. PWM).


--------------------------------------------------------------
2η ΒΑΡΔΙΑ
--------------------------------------------------------------

2.1) ΕΡΩΤΗΣΗ: Γιατί αρχικοποιούμε τον SP στην κορυφή (RAMEND) της μνήμης;

ΑΠΑΝΤΗΣΗ:
Η στοίβα στον AVR αναπτύσσεται προς τα κάτω (από υψηλές προς χαμηλές διευθύνσεις). Αρχικοποιώντας τον SP στο RAMEND (τελευταία θέση SRAM), δίνουμε στη στοίβα τον μέγιστο δυνατό χώρο για να μεγαλώσει χωρίς να επικαλύψει τις μεταβλητές και τα δεδομένα του προγράμματος που τοποθετούνται από τις χαμηλές διευθύνσεις της SRAM. Αν αρχικοποιηθεί αλλού, υπάρχει κίνδυνος σύγκρουσης δεδομένων με τη στοίβα (stack overflow).


2.2) ΕΡΩΤΗΣΗ: Πότε και γιατί κάνουμε αρχικοποίηση σε ένα πρόγραμμα AVR;

ΑΠΑΝΤΗΣΗ:
Η αρχικοποίηση γίνεται στην αρχή του κώδικα (μετά το reset vector) και περιλαμβάνει:
- Αρχικοποίηση Stack Pointer (SPH:SPL = RAMEND) για σωστή λειτουργία υπορουτινών/διακοπών.
- Ρύθμιση DDRx (κατεύθυνση I/O): ποιοι ακροδέκτες θα είναι είσοδοι και ποιοι έξοδοι.
- Αρχικοποίηση περιφερειακών (Timer, ADC, TWI, UART, LCD κ.λπ.).
- Ενεργοποίηση διακοπών (ρύθμιση EICRA, EIMSK, TIMSK1 κ.λπ. + sei).
Γιατί: Μετά από reset οι καταχωρητές έχουν προεπιλεγμένες τιμές (συνήθως 0), οι θύρες είναι είσοδοι, οι διακοπές απενεργοποιημένες, τα περιφερειακά σταματημένα. Χωρίς αρχικοποίηση, το πρόγραμμα δε θα λειτουργήσει σωστά.


2.3) ΕΡΩΤΗΣΗ: Γιατί βγάζει σφάλμα μέτρησης ένας ADC με μεγάλη αντίσταση εισόδου; Δύο τρόποι υλοποίησης ADC. ADC 10bit/10kHz σε 1-wire;

ΑΠΑΝΤΗΣΗ:
α) Σφάλμα μέτρησης: Ο ADC του AVR έχει εσωτερικό πυκνωτή δειγματοληψίας (Sample & Hold, C_S/H = 14pF). Αν η αντίσταση εισόδου είναι μεγάλη (>10KΩ), ο πυκνωτής δεν προλαβαίνει να φορτιστεί πλήρως μέσα στον χρόνο δειγματοληψίας (1.5 κύκλοι ADC clock), με αποτέλεσμα λανθασμένη μέτρηση.
Διόρθωση: (i) Χρήση buffer/op-amp πριν τον ADC (χαμηλή αντίσταση εξόδου). (ii) Μείωση της συχνότητας ρολογιού ADC ώστε να αυξηθεί ο χρόνος δειγματοληψίας.

β) Δύο τρόποι υλοποίησης ADC:
- Με έναν αναλογικό μετατροπέα (π.χ. διαδοχικών προσεγγίσεων SAR): Ένας μόνο ADC με πολυπλέκτη εισόδων. Πλεονέκτημα: μικρό μέγεθος/κόστος. Μειονέκτημα: δεν μπορεί να μετρά ταυτόχρονα πολλές εισόδους.
- Με πολλούς ψηφιακούς (π.χ. flash ADC / παράλληλοι συγκριτές): Ένας συγκριτής ανά στάθμη. Πλεονέκτημα: πολύ γρήγορη μετατροπή. Μειονέκτημα: πολύ μεγάλος αριθμός συγκριτών (2^n - 1), υψηλό κόστος/κατανάλωση.

γ) ADC 10bit/10kHz σε 1-wire: ΟΧΙ, δεν μπορεί. Το πρωτόκολλο 1-wire απαιτεί ελάχιστο 60μs ανά bit. Για 10 bit + overhead εντολών, μία μετατροπή χρειάζεται πάνω από 750msec (DS1820). Ο ρυθμός 10kHz = 1 δείγμα ανά 100μs είναι αδύνατος μέσω 1-wire.


--------------------------------------------------------------
3η ΒΑΡΔΙΑ
--------------------------------------------------------------

3.1) ΕΡΩΤΗΣΗ: Με 6 ελεύθερους ακροδέκτες, πληκτρολόγιο 9 κουμπιών - πώς;

ΑΠΑΝΤΗΣΗ:
Χρησιμοποιούμε matrix πληκτρολόγιο 3x3 (3 γραμμές + 3 στήλες = 6 ακροδέκτες, 9 κουμπιά).
- 3 ακροδέκτες ως έξοδοι (γραμμές) και 3 ως είσοδοι (στήλες) με pull-up αντιστάσεις.
- Σάρωση: Θέτουμε διαδοχικά κάθε γραμμή σε λογικό 0 (τις υπόλοιπες σε 1). Για κάθε γραμμή, διαβάζουμε τις στήλες. Αν κάποια στήλη είναι 0, σημαίνει ότι το αντίστοιχο πλήκτρο (τομή γραμμής-στήλης) είναι πατημένο.
- Η μέθοδος αυτή γενικεύεται: με N+M ακροδέκτες φτιάχνουμε NxM κουμπιά.


3.2) ΕΡΩΤΗΣΗ: Θα μπορούσε μικροελεγκτής χωρίς IN/OUT; Τι θα γινόταν;

ΑΠΑΝΤΗΣΗ:
Ναι, θα μπορούσε να λειτουργήσει χρησιμοποιώντας τις εντολές LDS/STS, που προσπελαύνουν τους I/O καταχωρητές μέσω του χώρου διευθύνσεων μνήμης (memory-mapped I/O). Κάθε I/O register έχει και αντίστοιχη διεύθυνση μνήμης (π.χ. PORTB = I/O 0x05 = μνήμη 0x25).
Επίπτωση στην απόδοση: Η IN/OUT εκτελείται σε 1 κύκλο μηχανής, ενώ η LDS/STS σε 2 κύκλους. Επίσης η LDS/STS καταλαμβάνει 2 λέξεις στη μνήμη προγράμματος (32 bit) αντί 1 λέξη (16 bit) της IN/OUT. Άρα ο κώδικας θα ήταν πιο αργός και θα έπαιρνε περισσότερο χώρο.


3.3) ΕΡΩΤΗΣΗ: Πώς λειτουργεί η στοίβα, δομή, παράδειγμα;

ΑΠΑΝΤΗΣΗ:
Η στοίβα (stack) είναι μια δομή LIFO (Last In, First Out) στην SRAM. Ο Stack Pointer (SP = SPH:SPL) δείχνει στην κορυφή.
- Λειτουργία: Αναπτύσσεται από ψηλά προς τα κάτω. Σε push, ο SP μειώνεται. Σε pop, ο SP αυξάνεται.
- Χρήσεις: (i) Αποθήκευση διεύθυνσης επιστροφής κατά rcall/call. (ii) Σώσιμο καταχωρητών με push/pop. (iii) Αυτόματη αποθήκευση PC + SREG σε διακοπές.
Παράδειγμα:
  push r16     ; SP = SP-1, MEM[SP] = r16
  push r17     ; SP = SP-1, MEM[SP] = r17
  rcall myFunc ; SP = SP-2, MEM[SP] = PC (διεύθυνση επιστροφής)
  ; ... μέσα στη myFunc:
  ret          ; PC = MEM[SP], SP = SP+2
  pop r17      ; r17 = MEM[SP], SP = SP+1
  pop r16      ; r16 = MEM[SP], SP = SP+1


3.4) ΕΡΩΤΗΣΗ: Μετατροπή αναλογικού σε ψηφιακό χωρίς DAC;

ΑΠΑΝΤΗΣΗ:
Η ερώτηση αναφέρεται σε μετατροπή A/D χωρίς ξεχωριστό DAC. Μπορεί να γίνει π.χ. με:
- Single-slope ADC: Φόρτιση πυκνωτή μέσω σταθερού ρεύματος και μέτρηση χρόνου μέχρι η τάση του πυκνωτή να φτάσει την τάση εισόδου (χρήση αναλογικού συγκριτή + timer). Ο χρόνος είναι ανάλογος της τάσης εισόδου.
- Sigma-Delta: Χρήση 1-bit comparator και ψηφιακού φίλτρου/integrator.
- Flash ADC: Πολλαπλοί αναλογικοί συγκριτές σε σχέση με αντιστατικό διαιρέτη τάσης (δεν χρειάζεται DAC).
Στον AVR, ο ενσωματωμένος ADC χρησιμοποιεί τη μέθοδο διαδοχικών προσεγγίσεων (SAR), η οποία χρειάζεται εσωτερικό DAC (ήδη ενσωματωμένο).


3.5) ΕΡΩΤΗΣΗ: Πώς το TWI επιτρέπει πολλαπλές συσκευές και multi-master;

ΑΠΑΝΤΗΣΗ:
- Πολλαπλές συσκευές: Κάθε συσκευή στον δίαυλο TWI (I2C) έχει μοναδική 7-bit διεύθυνση. Ο Master στέλνει τη διεύθυνση μετά το START, και μόνο ο Slave με τη σωστή διεύθυνση απαντά με ACK. Έτσι συνδέονται έως 127 συσκευές στις ίδιες 2 γραμμές (SDA, SCL).
- Multi-master: Το TWI υποστηρίζει arbitration (διαιτησία). Αν δύο Masters ξεκινήσουν ταυτόχρονα, παρακολουθούν τη γραμμή SDA. Αν κάποιος στέλνει λογικό 1 αλλά διαβάζει 0 (κάποιος άλλος κρατά χαμηλά τη γραμμή), χάνει τη διαιτησία και σταματά. Αυτό λειτουργεί χάρη στις open-drain εξόδους και τις pull-up αντιστάσεις - οποιαδήποτε συσκευή μπορεί να τραβήξει τη γραμμή χαμηλά (wired-AND).


--------------------------------------------------------------
4η ΒΑΡΔΙΑ (ΕΞΕΤΑΣΗ ΦΕΒΡΟΥΑΡΙΟΣ 2023)
--------------------------------------------------------------

4.1) ΕΡΩΤΗΣΗ: Τι προβλήματα δημιουργεί η αναπήδηση/σπινθηρισμός και πώς αντιμετωπίζεται;

ΑΠΑΝΤΗΣΗ:
Πρόβλημα: Ένας πιεστικός διακόπτης, κατά το πάτημα ή την απελευθέρωση, δημιουργεί πολλαπλές γρήγορες εναλλαγές (bouncing) λόγω μηχανικού σπινθηρισμού. Αν η εξωτερική διακοπή ενεργοποιείται σε ακμή, θα προκληθούν πολλές ανεπιθύμητες διακοπές από ένα μόνο πάτημα.
Αντιμετώπιση (debouncing):
- Software: Στη ρουτίνα εξυπηρέτησης διακοπής, μηδενίζουμε τη σημαία INTFx. Περιμένουμε ~5ms. Ελέγχουμε αν η σημαία ξαναέγινε 1 (= νέος σπινθηρισμός). Αν ναι, επαναλαμβάνουμε. Αν όχι, οι αναπηδήσεις σταμάτησαν και προχωράμε στην εξυπηρέτηση.
- Hardware: Χρήση RC κυκλώματος ή Schmitt trigger.


4.2) ΕΡΩΤΗΣΗ: Μηχανισμός διακοπής υπερχείλισης Timer/Counter1

ΑΠΑΝΤΗΣΗ:
Ο Timer/Counter1 (TCNT1) είναι 16-bit. Ενεργοποίηση:
1. Επιλογή prescaler (CS12:CS10 στον TCCR1B), π.χ. CLK/1024.
2. Φόρτωση αρχικής τιμής στον TCNT1 (πρώτα TCNT1H, μετά TCNT1L).
3. Ενεργοποίηση διακοπής: sts TIMSK1 με TOIE1=1.
4. sei για γενική ενεργοποίηση διακοπών.
Λειτουργία: Ο TCNT1 αυξάνεται με τη συχνότητα CLK/prescaler. Όταν υπερχειλίσει (0xFFFF -> 0x0000), τίθεται η σημαία TOV1 στον TIFR1 και εκτελείται η ISR στο vector 0x1A. Μετά την εξυπηρέτηση, πρέπει να ξαναφορτωθεί ο TCNT1 με την αρχική τιμή.


4.3) ΕΡΩΤΗΣΗ: Σύγκριση TWI με 1-Wire

ΑΠΑΝΤΗΣΗ:
TWI (I2C):
- 2 γραμμές: SDA (δεδομένα) + SCL (ρολόι)
- Ταχύτητα: 100kHz (standard), 400kHz (fast)
- Έως 127 συσκευές
- Υποστήριξη multi-master
- Ξεχωριστό ρολόι (σύγχρονο πρωτόκολλο)

1-Wire:
- 1 μόνο γραμμή δεδομένων + GND
- Πολύ χαμηλή ταχύτητα (~16kbps)
- Κάθε συσκευή έχει μοναδικό 64-bit κωδικό
- Μόνο ένας master
- Χρονισμός μέσω time-slots (ασύγχρονο)
- Απαιτεί pull-up αντίσταση
- Ελάχιστη καλωδίωση (ιδανικό για αισθητήρες)


4.4) ΕΡΩΤΗΣΗ: Ποια είναι η χρήση των διακοπών σε μικροελεγκτή;

ΑΠΑΝΤΗΣΗ:
Οι διακοπές (interrupts) επιτρέπουν στον μικροελεγκτή να ανταποκρίνεται άμεσα σε εξωτερικά ή εσωτερικά γεγονότα χωρίς να ελέγχει συνεχώς (polling).
Χρήσεις:
- Εξωτερικές διακοπές (INT0/INT1): Αντίδραση σε πάτημα πλήκτρου ή εξωτερικό σήμα.
- Διακοπές Timer: Χρονισμός εργασιών σε τακτά διαστήματα.
- Διακοπές ADC: Ειδοποίηση ότι ολοκληρώθηκε αναλογική μετατροπή.
- Διακοπές TWI/UART: Ειδοποίηση για ολοκλήρωση μεταφοράς δεδομένων.
Η CPU σώζει αυτόματα τον PC στη στοίβα, εκτελεί τη ρουτίνα εξυπηρέτησης (ISR) και μετά επιστρέφει (reti) στο σημείο που διακόπηκε.


4.5) ΕΡΩΤΗΣΗ: Τι θα συμβεί αν κατά την ανάγνωση πληκτρολογίου είναι πατημένα ταυτόχρονα δύο πλήκτρα;

ΑΠΑΝΤΗΣΗ:
Εξαρτάται από τη θέση τους:
- Ίδια γραμμή, διαφορετικές στήλες: Θα ανιχνευτούν και τα δύο, γιατί οι δύο στήλες θα γίνουν 0 ταυτόχρονα.
- Ίδια στήλη, διαφορετικές γραμμές: Θα ανιχνευτεί μόνο ένα (αυτό της γραμμής που σαρώνεται εκείνη τη στιγμή).
- Διαφορετική γραμμή ΚΑΙ στήλη: Μπορεί να δημιουργηθεί "phantom key" (φάντασμα πλήκτρου). Π.χ. αν πατήσω (γραμμή1, στήλη1) και (γραμμή2, στήλη2), θα φαίνεται ότι είναι πατημένα και τα (γραμμή1, στήλη2) και (γραμμή2, στήλη1). Λύση: χρήση διόδων σε κάθε πλήκτρο ή N-key rollover λογική.


--------------------------------------------------------------
ΤΕΛΕΥΤΑΙΑ ΒΑΡΔΙΑ
--------------------------------------------------------------

5.1) ΕΡΩΤΗΣΗ: Περιγραφή ανάγνωσης 16bit καταχωρητή Timer (TEMP register)

ΑΠΑΝΤΗΣΗ:
Ο TCNT1 είναι 16-bit αλλά ο δίαυλος δεδομένων είναι 8-bit. Για ατομική (αδιαίρετη) ανάγνωση χρησιμοποιείται ο προσωρινός καταχωρητής TEMP:
- Ανάγνωση: Πρώτα διαβάζουμε τον TCNT1L. Ταυτόχρονα, το hardware αντιγράφει αυτόματα τον TCNT1H στον TEMP. Μετά διαβάζουμε τον TCNT1H (παίρνουμε την τιμή από τον TEMP). Έτσι τα 16 bit αντιστοιχούν στην ίδια χρονική στιγμή.
- Εγγραφή: Πρώτα γράφουμε τον TCNT1H (πάει στον TEMP). Μετά γράφουμε τον TCNT1L, και τότε τα 16 bit γράφονται ταυτόχρονα.
Σημαντικό: Σε πολύπλοκες εφαρμογές, μπορεί να χρειαστεί απενεργοποίηση διακοπών πριν την πρόσβαση.


5.2) ΕΡΩΤΗΣΗ: Πιν στα 5V, κλείσιμο διακόπτη - τι γίνεται και πώς αποφεύγεται;

ΑΠΑΝΤΗΣΗ:
Αν ένας ακροδέκτης του μικροελεγκτή είναι ρυθμισμένος ως έξοδος στα 5V (λογικό 1) και ο διακόπτης τον συνδέσει απευθείας στη γη (GND), τότε δημιουργείται βραχυκύκλωμα: ρεύμα ρέει απευθείας από VCC στο GND μέσω του εσωτερικού transistor του ακροδέκτη, που μπορεί να τον καταστρέψει.
Αποφυγή: Πάντα τοποθετούμε μια αντίσταση σειράς (π.χ. 220Ω-10KΩ) μεταξύ του ακροδέκτη και του διακόπτη, για να περιορίσουμε το ρεύμα. Εναλλακτικά, ρυθμίζουμε τον ακροδέκτη ως είσοδο με pull-up αντίσταση αντί ως έξοδο.


5.3) ΕΡΩΤΗΣΗ: Χρήση RAM και ROM στον AVR

ΑΠΑΝΤΗΣΗ:
- Flash (ROM): Μη πτητική μνήμη προγράμματος. Αποθηκεύει τον κώδικα (εντολές) και σταθερές (lookup tables, strings). Στον ATmega328PB: 32KB. Προγραμματίζεται εξωτερικά, διατηρεί τα δεδομένα χωρίς τροφοδοσία.
- SRAM (RAM): Πτητική μνήμη δεδομένων. Αποθηκεύει μεταβλητές, τη στοίβα (stack), ενδιάμεσα αποτελέσματα κατά την εκτέλεση. Στον ATmega328PB: 2KB (0x0100-0x08FF). Χάνει τα δεδομένα χωρίς τροφοδοσία.
- EEPROM: Μη πτητική μνήμη δεδομένων για αποθήκευση ρυθμίσεων/παραμέτρων που πρέπει να διατηρηθούν μετά από απώλεια τροφοδοσίας. Στον ATmega328PB: 1KB.


5.4) ΕΡΩΤΗΣΗ: Θερμόμετρο 0.1°C / 1msec μέσω 1-wire - γίνεται;

ΑΠΑΝΤΗΣΗ:
ΟΧΙ, δεν γίνεται. Λόγοι:
- Ο αισθητήρας DS1820 χρειάζεται μέχρι 750ms για μία μέτρηση (ακρίβεια 9-bit = 0.5°C). Ο DS18B20 χρειάζεται ~750ms για 12-bit (0.0625°C). Δεν μπορεί να μετρήσει κάθε 1ms.
- Η ακρίβεια 0.1°C απαιτεί ανάλυση τουλάχιστον 11-12 bit, που σημαίνει μεγαλύτερο χρόνο μετατροπής.
- Το πρωτόκολλο 1-wire είναι αργό: κάθε bit χρειάζεται ~60μs time slot. Η μεταφορά 16 bit + εντολές + reset παίρνει πολλά ms.
Συνεπώς, ούτε ο χρόνος μετατροπής ούτε η ταχύτητα επικοινωνίας επαρκούν.


5.5) ΕΡΩΤΗΣΗ: Γιατί ο SP αρχικοποιείται στην κορυφή της μνήμης;

ΑΠΑΝΤΗΣΗ:
(Ίδια με 2.1) Η στοίβα αναπτύσσεται προς τα κάτω. Αρχικοποιώντας στο RAMEND (0x08FF για ATmega328PB), εξασφαλίζουμε μέγιστο χώρο ανάπτυξης. Τα δεδομένα/μεταβλητές τοποθετούνται στις χαμηλές διευθύνσεις SRAM (από 0x0100), ενώ η στοίβα μεγαλώνει από 0x08FF προς τα κάτω. Έτσι ελαχιστοποιείται ο κίνδυνος σύγκρουσης.


--------------------------------------------------------------
ΓΕΝΙΚΕΣ ΕΡΩΤΗΣΕΙΣ
--------------------------------------------------------------

Γ.1) ΕΡΩΤΗΣΗ: Τι κάνει η pull-up αντίσταση;

ΑΠΑΝΤΗΣΗ:
Η pull-up αντίσταση συνδέει έναν ακροδέκτη εισόδου στην τάση τροφοδοσίας (VCC/VDD) μέσω μιας αντίστασης υψηλής τιμής (π.χ. 10KΩ). Έτσι:
- Όταν δεν πατιέται κανένα πλήκτρο, ο ακροδέκτης διαβάζει λογικό 1 (σταθερή κατάσταση).
- Όταν πατηθεί ο διακόπτης (που συνδέει τον ακροδέκτη στη γη), ο ακροδέκτης γίνεται λογικό 0.
Χωρίς pull-up, ο ακροδέκτης θα ήταν "floating" (αόριστη κατάσταση) όταν ο διακόπτης δεν είναι πατημένος, δίνοντας τυχαίες τιμές. Ο AVR διαθέτει εσωτερικές pull-up αντιστάσεις που ενεργοποιούνται γράφοντας 1 στο PORTx με τον ακροδέκτη ρυθμισμένο ως είσοδο. Στο TWI bus, οι pull-up αντιστάσεις είναι εξωτερικές και απαραίτητες γιατί οι γραμμές SDA/SCL είναι open-drain.


Γ.2) ΕΡΩΤΗΣΗ: Διαφορά μικροελεγκτή και μικροεπεξεργαστή

ΑΠΑΝΤΗΣΗ:
Μικροεπεξεργαστής: Περιέχει μόνο CPU (ALU, καταχωρητές, μονάδα ελέγχου). Χρειάζεται εξωτερικά: RAM, ROM, θύρες I/O, timers κ.λπ. Σχεδιασμένος για υψηλή υπολογιστική ισχύ (υπολογιστές, servers). Π.χ. Intel Core, AMD Ryzen.

Μικροελεγκτής: Ολοκληρωμένο σύστημα σε ένα chip. Περιέχει CPU + Flash (ROM) + SRAM (RAM) + EEPROM + θύρες I/O + Timers + ADC + TWI/SPI/UART κ.λπ. Σχεδιασμένος για ενσωματωμένες εφαρμογές ελέγχου (αυτοματισμοί, IoT). Χαμηλότερο κόστος, χαμηλή κατανάλωση, αυτάρκεια. Π.χ. ATmega328PB, PIC, STM32.
